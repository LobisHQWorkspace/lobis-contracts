{
  "language": "Solidity",
  "sources": {
    "contracts/migrator/Migrator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n}\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    // This method relies in extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n\ninterface IERC20 {\n  function decimals() external view returns (uint8);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(\n      data,\n      \"SafeERC20: low-level call failed\"\n    );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n\ninterface IUniswapV2Router {\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface ITreasury {\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (uint256);\n\n  function withdraw(uint256 _amount, address _token) external;\n\n  function tokenValue(address _token, uint256 _amount)\n    external\n    view\n    returns (uint256 value_);\n\n  function mint(address _recipient, uint256 _amount) external;\n\n  function manage(address _token, uint256 _amount) external;\n\n  function incurDebt(uint256 amount_, address token_) external;\n\n  function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n  function excessReserves() external view returns (uint256);\n\n  function baseSupply() external view returns (uint256);\n}\n\ninterface IMigrator {\n  enum TYPE {\n    UNSTAKED,\n    STAKED,\n    WRAPPED\n  }\n\n  // migrate OHMv1, sOHMv1, or wsOHM for OHMv2, sOHMv2, or gOHM\n  function migrate(\n    uint256 _amount,\n    TYPE _from,\n    TYPE _to\n  ) external;\n}\n\ncontract LiquidityMigrator {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  address public policy;\n  address public leftoverRecipient;\n\n  ITreasury internal immutable treasury =\n    ITreasury(0x873ad91fA4F2aA0d557C0919eC3F6c9D240cDd05);\n\n  IERC20 internal immutable oldOHM =\n    IERC20(0x383518188C0C6d7730D91b2c03a03C837814a899);\n\n  IERC20 internal immutable newOHM =\n    IERC20(0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5);\n\n  IMigrator internal immutable migrator =\n    IMigrator(0x184f3FAd8618a6F458C16bae63F70C426fE784B3);\n\n  constructor(address _leftoverRecipient) public {\n    policy = msg.sender;\n    leftoverRecipient = _leftoverRecipient;\n  }\n\n  modifier onlyPolicy() {\n    require(msg.sender == policy, \"!policy\");\n    _;\n  }\n\n  /**\n   * @notice Migrate LP and pair with new OHM\n   */\n  function migrateLP(\n    address pair,\n    IUniswapV2Router routerFrom,\n    IUniswapV2Router routerTo,\n    address token,\n    uint256 _minA,\n    uint256 _minB,\n    uint256 _deadline\n  ) external onlyPolicy {\n    // Since we are adding liquidity, any existing balance should be excluded\n    uint256 initialNewOHMBalance = newOHM.balanceOf(address(this));\n    // Fetch the treasury balance of the given liquidity pair\n    uint256 oldLPAmount = IERC20(pair).balanceOf(address(treasury));\n    treasury.manage(pair, oldLPAmount);\n\n    // Remove the V1 liquidity\n    IERC20(pair).approve(address(routerFrom), oldLPAmount);\n\n    (uint256 amountToken, uint256 amountOHM) = routerFrom.removeLiquidity(\n      token,\n      address(oldOHM),\n      oldLPAmount,\n      _minA,\n      _minB,\n      address(this),\n      _deadline\n    );\n\n    // Migrate the V1 OHM to V2 OHM\n    oldOHM.approve(address(migrator), amountOHM);\n    migrator.migrate(\n      amountOHM,\n      IMigrator.TYPE.UNSTAKED,\n      IMigrator.TYPE.UNSTAKED\n    );\n    uint256 amountNewOHM = newOHM.balanceOf(address(this)).sub(\n      initialNewOHMBalance\n    ); // # V1 out != # V2 in\n\n    // Add the V2 liquidity\n    IERC20(token).approve(address(routerTo), amountToken);\n    newOHM.approve(address(routerTo), amountNewOHM);\n\n    routerTo.addLiquidity(\n      token,\n      address(newOHM),\n      amountToken,\n      amountNewOHM,\n      amountToken,\n      amountNewOHM,\n      address(treasury),\n      _deadline\n    );\n\n    // Send any leftover balance to the governor\n    newOHM.safeTransfer(leftoverRecipient, newOHM.balanceOf(address(this)));\n    oldOHM.safeTransfer(leftoverRecipient, oldOHM.balanceOf(address(this)));\n\n    IERC20(token).safeTransfer(\n      leftoverRecipient,\n      IERC20(token).balanceOf(address(this))\n    );\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}